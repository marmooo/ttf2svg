import { parse } from "opentype.js";
import svgpath from "svgpath";
import { parseLigatures } from "./ligature.js";

export { parse };

function svgHeader(font, options = {}) {
  const {
    width = null,
    height = null,
    metrics = "typo",
  } = options;
  const os2 = font.tables.os2;
  let asc, desc;
  if (metrics === "typo" && os2) {
    asc = os2.sTypoAscender;
    desc = os2.sTypoDescender;
  } else if (metrics === "win" && os2) {
    asc = os2.usWinAscent;
    desc = -os2.usWinDescent;
  } else {
    asc = font.ascender;
    desc = font.descender;
  }
  if (desc > 0) desc = -desc;
  const widthAttr = width ? `width="${width}"` : "";
  const heightAttr = height ? `height="${height}"` : "";
  const upm = font.unitsPerEm;
  const vh = asc - desc;
  const copyright = fontToCopyright(font);
  let svg = `<svg xmlns="http://www.w3.org/2000/svg"
  ${widthAttr} ${heightAttr} viewBox="0 0 ${upm} ${vh}">
`;
  if (copyright != "") {
    svg += `  <!--
${copyright}
  -->
`;
  }
  return svg;
}

export function toSVG(font, glyph, options = {}) {
  const { metrics = "typo" } = options;
  const os2 = font.tables.os2;
  let asc;
  if (metrics === "typo" && os2) {
    asc = os2.sTypoAscender;
  } else if (metrics === "win" && os2) {
    asc = os2.usWinAscent;
  } else {
    asc = font.ascender;
  }
  const translateY = options.translateY ?? asc;
  const d = svgpath(glyph.path.toPathData())
    .scale(1, -1)
    .translate(0, translateY)
    .toString();
  if (d == "") return undefined;
  const path = `<path d="${d}"/>`;
  return svgHeader(font, options) + path + "\n</svg>";
}

function getInfo(hash) {
  if (!hash) return "";
  const arr = Object.values(hash);
  if (arr.length > 0) {
    return arr[0];
  } else {
    return "";
  }
}

function fontToCopyright(font) {
  const copyrights = font.names.copyright
    ? Object.values(font.names.copyright).join("\n")
    : "";
  const trademarks = font.names.trademark
    ? Object.values(font.names.trademark).join("\n")
    : "";
  const licenses = font.names.license
    ? Object.values(font.names.license).join("\n")
    : "";
  const licenseURLs = font.names.licenseURL
    ? Object.values(font.names.licenseURL).join("\n")
    : "";
  const infos = [copyrights, trademarks, licenses, licenseURLs];
  return infos.filter((info) => info).join("\n");
}

function glyphHeader(font, options) {
  const { metrics = "typo" } = options;
  const os2 = font.tables.os2;
  let asc, desc, lineGap;
  if (metrics === "typo" && os2) {
    asc = os2.sTypoAscender;
    desc = os2.sTypoDescender;
    lineGap = os2.sTypoLineGap;
  } else if (metrics === "win" && os2) {
    asc = os2.usWinAscent;
    desc = -os2.usWinDescent;
    lineGap = 0;
  } else {
    asc = font.ascender;
    desc = font.descender;
    lineGap = font.tables.hhea?.lineGap ?? 0;
  }
  const height = asc - desc + lineGap;
  let header = `<svg xmlns="http://www.w3.org/2000/svg">
`;
  const copyright = fontToCopyright(font);
  if (copyright != "") {
    header += `<!--
${copyright}
  -->
`;
  }
  header += `
  <defs>
    <font name="${getInfo(font.names.fullName)}"
      horiz-adv-x="${font.unitsPerEm}" vert-adv-y="${height}" >
    <font-face font-family="${getInfo(font.names.fontFamily)}" font-weight="400"
      font-stretch="normal"
      units-per-em="${font.unitsPerEm}"
      ascent="${font.ascender}"
      descent="${font.descender}"/>
`;
  return header;
}

function glyphFooter() {
  return `
    </font>
  </defs>
</svg>`;
}

export function toSVGFont(font, glyphs, options) {
  return glyphHeader(font, options) + toGlyphTags(font, glyphs, options) +
    glyphFooter();
}

export function toGlyphTags(font, glyphs, options) {
  const lineGap = font.tables.hhea?.lineGap ?? 0;
  const height = font.ascender - font.descender + lineGap;
  let svg = "";
  for (let i = 0; i < glyphs.length; i++) {
    const glyph = glyphs[i];
    if (!glyph.unicode) continue; // .notdef
    let d = glyph.path.toPathData();
    // "M0 0L0 0Z" is an empty path generated by opentype.js.
    // svgttf requires unique path data, so provide empty coordinate data.
    if (d == "M0 0L0 0Z") d = `M0 ${i}Z`;
    const unicode = (glyph.unicode === 34)
      ? "&#34;" // escape '"'
      : String.fromCodePoint(glyph.unicode);
    const glyphNameAttr = glyph.name ? `glyph-name="${glyph.name}"` : "";
    svg += `    <glyph ${glyphNameAttr} unicode="${unicode}"
      horiz-adv-x="${glyph.advanceWidth}" vert-adv-y="${height}"
      d="${d}"/>
`;
  }
  if (!options.removeLigatures) {
    for (const ligature of parseLigatures(font)) {
      const glyph = glyphs[ligature.by];
      if (!glyph) continue;
      const d = glyph.path.toPathData();
      const glyphNameAttr = glyph.name ? `glyph-name="${glyph.name}"` : "";
      svg += `    <glyph ${glyphNameAttr} unicode="${ligature.name}"
      horiz-adv-x="${glyph.advanceWidth}" vert-adv-y="${height}"
      d="${d}"/>
`;
    }
  }
  if (options.removeNotdef) {
    return svg;
  } else {
    const notdefGlyph = font.glyphs.get(0);
    const d = notdefGlyph.path.toPathData();
    const notDef = `    <missing-glyph glyph-name=".notdef"
      horiz-adv-x="${notdefGlyph.advanceWidth}" vert-adv-y="${height}"
      d="${d}"/>`;
    return svg + notDef;
  }
}

function filterByNameSet(font, nameSet) {
  const result = [];
  for (const glyph of Object.values(font.glyphs.glyphs)) {
    if (nameSet.has(glyph.name)) result.push(glyph);
  }
  return result;
}

function filterByLigatureSet(font, ligatureSet) {
  const glyphs = font.glyphs.glyphs;
  const result = [];
  for (const ligature of parseLigatures(font)) {
    if (ligatureSet.has(ligature.name)) {
      const glyph = glyphs[ligature.by.toString()];
      if (glyph) result.push(glyph);
    }
  }
  return result;
}

export function filterGlyphs(font, options = {}) {
  if (options.textFile) {
    const text = Deno.readTextFileSync(options.textFile);
    const glyphString = text.trimEnd().replace(/\n/g, "");
    return font.stringToGlyphs(glyphString);
  } else if (options.codeFile) {
    const text = Deno.readTextFileSync(options.codeFile);
    const glyphString = text.trimEnd().split("\n")
      .map((line) => String.fromCodePoint(Number(line))).join("");
    return font.stringToGlyphs(glyphString);
  } else if (options.nameFile) {
    const text = Deno.readTextFileSync(options.nameFile);
    const nameSet = new Set(text.trimEnd().split("\n"));
    return filterByNameSet(font, nameSet);
  } else if (options.ligatureFile) {
    const text = Deno.readTextFileSync(options.ligatureFile);
    const ligatureSet = new Set(text.trimEnd().split("\n"));
    return filterByLigatureSet(font, ligatureSet);
  } else if (options.text) {
    return font.stringToGlyphs(options.text);
  } else if (options.code) {
    const glyphString = options.code.split(",")
      .map((code) => String.fromCodePoint(Number(code))).join("");
    return font.stringToGlyphs(glyphString);
  } else if (options.name) {
    const nameSet = new Set(options.name.split(","));
    return filterByNameSet(font, nameSet);
  } else if (options.ligature) {
    const ligatureSet = new Set(options.ligature.split(","));
    return filterByLigatureSet(font, ligatureSet);
  } else {
    return Object.values(font.glyphs.glyphs);
  }
}

export function font2svg(font, options) {
  const glyphs = filterGlyphs(font, options);
  return glyphs.map((glyph) => {
    return toSVG(font, glyph, options);
  });
}

export function ttf2svg(uint8array, options = {}) {
  const font = parse(uint8array.buffer);
  return font2svg(font, options);
}

export function ttf2svgFont(uint8array, options = {}) {
  const font = parse(uint8array.buffer);
  return font2svgFont(font, options);
}

export function font2svgFont(font, options = {}) {
  const glyphs = filterGlyphs(font, options);
  return toSVGFont(font, glyphs, options);
}
